<script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>sagecell.makeSagecell({"inputLocation": ".sage",
                               hide: ["editor","evalButton"],
                       autoeval: true});</script>


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Chris Cox</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/paper/bootstrap.min.css" type="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
</head>
<body style="background-color:#e6e6ff;">
  

  
    <nav class="navbar navbar-default navbar-static-top">
    <nav class="navbar navbar-light" style="background-color: #e6e6ff;">
    <div class="container">
      <div class="navbar-header">
      	<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
                <a class="navbar-brand" href="https://epistibrain.github.io/">Chris Cox</a> 
            	</div>
    	
    	
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
 			 				<!--li ><a href="CoxResearch.html">Research</a></li>
 			 				<li ><a href="CoxTeaching.html">Teaching</a></li-->            
 			 				<li ><a href="CVCCOX1_7_21short.pdf">Short CV</a></li>         
 			 				<li ><a href="CoxPapers1_21.pdf">Publications</a></li>         
 			 				<li ><a href="CVCCOX_1_1_21-1.pdf">Long CV</a></li>
 			 				<li ><a href="CoxPersonal.html">Personal</a></li>
 			 				<!--li ><a href="Misc.html">Miscellaneous</a></li-->
 			          </ul>
          <ul class="nav navbar-nav navbar-right">
                  	  </ul>
        </div>
        
        
    </div>
  </nav>
 
      <p><img src="BilliardsTrim3.png" class="img-responsive center-block" width="1200"  /></p>
      
  
 </div>
</div>

<hr>
<img src="CZ.jpg"
 title = "ChrisandZeke"
 alt="C Cox" 
 width ="400" 
 height="300"
 align="left"
 border = "4 solid black"
 style="margin:0 10 0 0"/>
<br>
<br>
<font face="Verdana" size="4"> <p> I live in Elkton, Maryland, with my camera shy Border Collie Zeke. (I am on the left; Zeke is on the right.) <p>
              <p> Currently, I am a temporary Assistant Professor of Mathematics at the 
              <a href="https://www.mathsci.udel.edu/">University of Delaware</a>. 
              In 2016, I completed my PhD in mathematics under the direction of <a href="https://www.math.wustl.edu/~feres/">Renato Feres</a> at 
              <a href="https://math.wustl.edu">Washington University in St. Louis</a>, 
              where I also spent a year as a postdoctoral teaching fellow. 
              
              Before getting my PhD I taught math at <a href="https://www.icc.edu">Illinois Central College.</a>  </p></font><br />
<br><br>
<hr>
      
      

  <h2 id="billiards">An Interactive Introduction to Mathematical Billiards</h2>    
  <font face="Verdana" size="4"> <p>    One of my areas of research is billiard dynamics, using both analytic approaches and numerical simulation. This is designed to be an interactive 
  introduction for students or anyone who is interested. While it turns out that such dynamical systems are broadly applicable, as the name suggests, 
  they may be visualized as the paths of billiard balls as they move until they collide with a wall and then bounce off. For our model, we assume no energy
  is lost, so they never slow and stop. While our table might resemble a rectangular billiard table (without pockets), more generally we consider tables of any shape you can imagine.</p></font><br />

Choices for the simulation:
   <ul>
      <font face="Verdana" size="4">
  <li>Billiard table: Choose from a variety of shapes</li>
  <li>Mass distribution: We assume our ball is very small relative to the table size and we only draw the path, but the mass distribution will influence the collisions at walls. For example, if all the mass is at a point, spin does not matter and the collisions will be "angle in equals angle out." On the other hand, if the balls have even (uniform) mass or all the mass is at the rim (hollow) more interesting collisions occur.</li>
  <li>Number of collisions: Determines how long to run the simulation.</li>
  <li>Angle: The red arrow gives the starting direction of the billiard. This angle can be changed. Note that it is measured from the inward normal, so 0 degrees would be straight out.</li>
  <li> Spin: We can put English on the balls! The spin will change at collisions for Uniform and Hollow settings.</li> 
</ul> 
  <p>
     One of the general questions we are interested in is when is there regularity and structure and when is there seeming randomness and choatic behavior? Feel free to play around and investigate informally, or consider some of the specific questions given below.
     </p></font><br />
<div class="sage">
  <script type="text/x-sage">
#################################################
###### Introduction to Billiards ################
#################################################

import numpy as np
import math

#################################################
############## ellipse import ###################
#################################################

BorderColor='mediumseagreen'
TrajColor='midnightblue'

# The graphics file where we store the images
graph=Graphics()


#a 3X3 matrix that that rotates the second and third coordinates by rotation_angle
# This will be used to change from the coordinates at the wall to standard coordinates
def rotation(rotation_angle):  
    return np.matrix([[-1,0,0],[0,cos(rotation_angle),-sin(rotation_angle)],[0,sin(rotation_angle),cos(rotation_angle)]])


# This gives the collision transformation in coodinates with the normal upward in the direction of the third coordinate
# First coordinate is rotational velocity, second tangential, and third is normal
# This might look unnecessarily complicated Notice we have g=gamma=0, which makes it very simple
def reflection(g):
    return np.matrix([[-(1-g^2)/(1+g^2),-2*g/(1+g^2),0],[-2*g/(1+g^2),(1-g^2)/(1+g^2),0],[0,0,-1]])


# This finds the new position, given by the next collision point
# state=the current state, one row of the states matrix
# g is the mass disribution, always zero for now

def new_pos(state,e):
    #print(state)
    A=RR((1-e)*(state[4])^2+(state[5])^2)
    B=RR(2*(1-e)*(state[1]*state[4])+2*state[2]*state[5])
    C=RR((1-e)*(state[1])^2+(state[2])^2)+(e-1)
    #print(A,B,C)
    t=RR((-B+(B^2-4*A*C)^.5)/(2*A))
    state=[state[0]+t*state[3],state[1]+t*(state[4]),state[2]+t*(state[5]),state[3],state[4],state[5]]
    return state



def normalshift(x,y,e):
    if y>0:
        if x<0:
            return RR(-pi/2-arctan(y/(x*(1-e))))
        if x>0:
            return RR(-arctan(y/(x*(1-e)))+pi/2)
        else:
            return RR(0)
    if y<0:
        if x<0:
            return RR(-pi/2-arctan(y/(x*(1-e))))
        if x>0:
            return RR(-arctan(y/(x*(1-e)))+pi/2)
        else:
            return RR(pi)
    else:
        if x<0:
            return RR(-pi/2)
        else:
            return RR(pi/2)

# This finds the new velocity after the collision
# state=the current state, one row of the states matrix
# g is the mass disribution, always zero for now
# e=eccentricity squared
def new_vel(state,g,e):
    normal_angle=normalshift(state[1],state[2],e)
    #print(normal_angle)
    #OLD:normal_angle=RR(arctan(state[2]/(state[1]*(1-e)))-pi/2)
    #print(normal_angle)
    velocity=np.matrix([ [state[3] ],[state[4] ],[state[5] ] ])
    # To get the new velocity, we rotate to standard position, apply the collision matrix, then rotate back
    velocity_rel=reflection(g)*rotation(normal_angle)*velocity
    velocity=rotation(-normal_angle)*reflection(g)*rotation(normal_angle)*velocity
    state=[state[0],state[1],state[2],velocity[0,0],velocity[1,0],velocity[2,0],velocity_rel[1,0],velocity_rel[2,0]]
    return state

# Each iteration involves finding the new position and then finding the new velocity after the collision
# state=the current state, one row of the states matrix
# g is the mass disribution, always zero for now
# e=eccentricity squared
def F(state, g,e):
    state=new_pos(state, e)
    state=new_vel(state, g,e)
    return state


###############################
##### end ellipse import ######
###############################



m=4 #positions
n=4 #velocities
eps=0.000000000001
res=100
large=1000
eps2=.001

P0=matrix(RR,m,n)
V0=matrix(RR,m,n)
P1=matrix(RR,m,n)
V1=matrix(RR,m,n)
P2=matrix(RR,m,n)
V2=matrix(RR,m,n)

#rough collisions
def rot(x):
    return matrix(RR,[[-1,0,0],[0,cos(x),-sin(x)],[0,sin(x),cos(x)]])


def f2(p,q):
    # gives lambda, required mass distribution, for given rotation angle  
    return (2-(2+2*(cos(2*pi*p/q)))^.5)^-.5

def gamm(la):
    return (4*la^2-1)^.5

def aa(gam):
    return (1-gam^2)/(1+gam^2)
    
def bb(gam):
    return 2*gam/(1+gam^2)


#U=matrix(RR,[[-a,b,0],[b,a,0],[0,0,-1]]) #rough collision with upward normal
S=matrix(RR,[[1,0,0],[0,1,0],[0,0,-1]]) #specular collision with upward normal


def create_matrices(p,v):
    P0=matrix(RR,m,n)
    V0=matrix(RR,m,n)
    P1=matrix(RR,m,n)
    V1=matrix(RR,m,n)
    P2=matrix(RR,m,n)
    V2=matrix(RR,m,n)
    for i in range(0,m):
        for j in range(0,n):
            P0[i,j]=p[i][0]
    for i in range(0,m):
        for j in range(0,n):
            P1[i,j]=p[i][1]
    for i in range(0,m):
        for j in range(0,n):
            P2[i,j]=p[i][2]
    for i in range(0,m):
        for j in range(0,n):
            V0[i,j]=v[j][0]
    for i in range(0,m):
        for j in range(0,n):
            V1[i,j]=v[j][1]
    for i in range(0,m):
        for j in range(0,n):
            V2[i,j]=v[j][2]
    return (P0,P1,P2,V0,V1,V2)

# walls library
# wall_segment= [ starting x, starting y, ending x, ending y, starting vector x, starting vector y, 0=circle 1=line for k>2 k=polynomial degree k, 0=not end 1=end, number of component,  0=smooth 1=rough,-(k+1)=pass to wall k ]


# basic functions concerning wall segments
def qb(wall_segment):
    return (wall_segment[0],wall_segment[1])
def qe(wall_segment):
    return (wall_segment[2],wall_segment[3])
def diff(u1,u2):
    return (u2[0]-u1[0],u2[1]-u1[1])
def veclen(u):
    return (u[0]^2+u[1]^2)^.5
def innprod(u1,u2):
    return u1[0]*u2[0]+u1[1]*u2[1]
# this returns the (smallest) angle between two vectors
def vecang(u1,u2):
    return RR(arccos(innprod(u1,u2)/(veclen(u1)*veclen(u2))))

def ub(wall_segment):
    w=(wall_segment[4],wall_segment[5])
    l=veclen(w)
    return (wall_segment[4]/l,wall_segment[5]/l)
# Testing simple functions above:
# show(veclen(diff(qb(easy_walls[1]),qe(easy_walls[1]))))

# normal vector from qb and qe 
def normal(u1,u2):
    w=diff(u1,u2)
    l=veclen(w)
    return (-w[1]/l,w[0]/l)
    
#show(normal(qb(easy_walls[1]),qe(easy_walls[1])))
def curv(u1,u2,u3):
    # u1=qb, u2=qe, u3=ub
    norm=normal(u1,u2)
    return 2*(u3[0]*norm[0]+u3[1]*norm[1])/veclen(diff(u1,u2))
#show(curv(qb(easy_walls[1]),qe(easy_walls[1]),ub(easy_walls[1])))

def ue(u1,u2,u3):
    # u1=qb, u2=qe, u3=ub
    norm=normal(u1,u2)
    l=(2*(u3[0]*norm[0]+u3[1]*norm[1]))
    w=(norm[0]*l,norm[1]*l)
    return diff(w,u3)
#show( ue( qb(easy_walls[1]),qe(easy_walls[1]),ub(easy_walls[1])) )

def theta(u1,u2,u3,u4):
    # qb,qe,ub,ue
    if innprod(diff(u1,u2),u3)>=0:
        return arccos(innprod(u3,u4))
    if innprod(diff(u1,u2),u3)<0:
        return 2*pi-arccos(innprod(u3,u4))
# show(theta(qb(easy_walls[1]), qe(easy_walls[1]), ub(easy_walls[1]), ue(qb(easy_walls[1]),qe(easy_walls[1]),ub(easy_walls[1]))))

def center(u1,u2,u3):
    #qb,qe,ub
    cu=curv(u1,u2,u3)+eps
    return diff((-u3[1]/cu,u3[0]/cu),u1)
#show(center(qb(easy_walls[1]), qe(easy_walls[1]), ub(easy_walls[1])))

def pdistance(u1,u2):
    return ((u1[0]-u2[0])^2+(u1[1]-u2[1])^2)^(1/2)

def getangle(A):
    # return the angle of the vector A relative to the pos x-axis
    if A[0]>=0:
        if A[1]>=0:
            return (arcsin((A[1]-eps)/veclen(A)))
        if A[1]<0:
            return (arcsin((A[1]+eps)/veclen(A)))
    else:
        #print('down here')
        return RR(pi-arcsin((A[1]-eps)/veclen(A)))
    
def circ_or(v,w):
    if v[0]*w[1]-v[1]*w[0]>0:
        #print('counter clockwise')
        return 0
    else:
        #print('clockwise')
        return 1
    
def draw_table(wall_segments):
    #print(len(wall_segments))
    newgraph=Graphics()
    for i in range(0,len(wall_segments)):
        #print('i',i)
        if wall_segments[i][6]==1:
            # draw line
            if wall_segments[i][9]==0:
                ourcolor='purple'
            else:
                ourcolor='green'
            newgraph+=plot(line([(wall_segments[i][0],wall_segments[i][1]),(wall_segments[i][2],wall_segments[i][3])],color=BorderColor,thickness=6))
            #ourcolor))
        if wall_segments[i][6]==0:
            u1=qb(wall_segments[i])
            u2=qe(wall_segments[i])
            u3=ub(wall_segments[i])
            u4=ue(u1,u2,u3)
            #print(u1,u2,u3,u4)
            C=center(u1,u2,u3)
            #print('center',C)
            arc_angle=RR(theta(u1,u2,u3,u4))
            #print('total angle', arc_angle)
            radius=1/abs(curv(u1,u2,u3))
            #print('radius', radius)
            x0=u1[0]
            y0=u1[1]
            startvec=diff(C,u1)
            #print('start vector',startvec)
            alpha=getangle(startvec)
            #print('alpha',alpha)
            for j in range(0,res+1):
                omega=(-1)^(circ_or(u3,diff(u1,u2)))*j/res*arc_angle
                #print(omega)
                #print(alpha)
                #print(radius*cos(alpha+omega),radius*sin(alpha+omega))
                #print(j,alpha+omega)
                x1=radius*cos(alpha+omega)+C[0]
                y1=radius*sin(alpha+omega)+C[1]
                #print(x1,y1)
                L=line([(x0,y0),(x1,y1)],color='black')
                newgraph=newgraph+plot(L)
                x0=x1
                y0=y1
                #show(newgraph)
        if wall_segments[i][6]>1:
            k=wall_segments[i][6]
            #print(k)
            x0=wall_segments[i][0]
            y0=wall_segments[i][1]
            xe=wall_segments[i][2]
            ye=wall_segments[i][3]
            
            if xe<x0 and ye>y0: 
                for j in range(1,res+1):
                    x1=-j/res+wall_segments[i][0]
                    y1=ye-(x1-xe)^k
                    L=line([(x0,y0),(x1,y1)],color='black')
                    newgraph=newgraph+plot(L)
                    x0=x1
                    y0=y1
            if xe<x0 and ye<y0: 
                for j in range(1,res+1):
                    x1=-j/res+wall_segments[i][0]
                    y1=wall_segments[i][1]-(-x1+wall_segments[i][0])^k
                    
                    L=line([(x0,y0),(x1,y1)],color='black')
                    newgraph=newgraph+plot(L)
                    x0=x1
                    y0=y1
            if xe>x0 and ye<y0: 
                for j in range(1,res+1):
                    x1=j/res+wall_segments[i][0]
                    y1=ye+(-1)^k*(-xe+x1)^k
                    #print(x0,y0,x1,y1)
                    L=line([(x0,y0),(x1,y1)],color='black')
                    newgraph=newgraph+plot(L)
                    x0=x1
                    y0=y1
            if xe>x0 and ye>y0: 
                for j in range(1,res+1):
                    x1=j/res+wall_segments[i][0]
                    y1=wall_segments[i][1]+(x1-wall_segments[i][0])^k
                    
                    L=line([(x0,y0),(x1,y1)],color='black')
                    newgraph=newgraph+plot(L)
                    x0=x1
                    y0=y1
                
    #show(newgraph)
    return newgraph

def draw_table_thickline(n,thick,s):
    if s==True:
        wall_segments=ngonth2(n,thick/200)
    else:
        wall_segments=ngonthr(n,thick/200)
    newgraph=Graphics()
    for i in range(0,len(wall_segments)):
        #print('i',i)
        if wall_segments[i][6]==1:
            # draw line
            if wall_segments[i][9]==0:
                ourcolor='purple'
            else:
                ourcolor='green'
            newgraph+=plot(line([(wall_segments[i][0],wall_segments[i][1]),(wall_segments[i][2],wall_segments[i][3])],color=ourcolor, thickness=thick))
    return newgraph


def pointonarc(x,y,wall):
    u1=qb(wall)
    u2=qe(wall)
    u3=ub(wall)
    u4=ue(u1,u2,u3)
    C=center(u1,u2,u3)
    thet=theta(u1,u2,u3,u4)
    v1=diff(C,(x,y))
    v2=diff(C,u1)
    ori=circ_or(diff(C,u1),diff(C,u2))
    #print('ori',ori)
    ang=vecang(v1,v2)
    #print('theta', thet, 'ang',ang)
    if circ_or(v1,v2)==0:
        angdis=2*pi-ang
    else:
        angdis=ang
    if ori==1 and (thet>pi+eps or thet<pi-eps):
        if thet>2*pi-angdis:
            #print('1')
            return True
        if thet<2*pi-angdis:
            return False
    if ori==0 and (thet>pi+eps or thet<pi-eps):
        if thet>angdis:
            #print('2')
            return True
        if thet<angdis:
            return False
    if thet==pi:
        if innprod(v1,u3)>0:
            return True
        else:
            return False
    
def wall_collide(pos,vel,wall):
    #print('in collide')
    #print(pos,vel,wall)
    # first check if the trajectory intersects the segment for linear boundaries
    # This first option only returns a value if the wall is linear and there is no collision
    # The second wall[6]==1 returns a value if there is a collision
    if wall[6]==1:
        v1=diff(pos,(wall[0],wall[1]))
        v2=diff(pos,(wall[2],wall[3]))
        #print(v1,v2,(vel[0],vel[1]))
        #print(vecang((vel[1],vel[2]),v1),vecang((vel[1],vel[2]),v2),vecang(v1,v2))
        #print(vecang((vel[1],vel[2]),v1)+vecang((vel[1],vel[2]),v2))
        angle_difference=vecang((vel[0],vel[1]),v1)+vecang((vel[0],vel[1]),v2)-vecang(v1,v2) #note cannot use vel directly as it is 3D
        #print(angle_difference)
        if angle_difference>0.001:
            #print('does not collide')
            return (0,0,large+1)
    
    
    
    
    # Note: works for only some circles--need better solution
    # It will excluse some legitimate circles if the trajectory passes in and out the arc
    # 10-17-17: modified to include polynomial walls
    if wall[6]>1:
        #print('poly wall',pos,vel)
        k=wall[6]
        x1=pos[0]
        y1=pos[1]
        x0=wall[0]
        y0=wall[1]
        xe=wall[2]
        ye=wall[3]
        if vel[0]!=0:
            vx=vel[0]
        else:
            vx=0.0000000000001
        vy=vel[1]
        if xe<x0 and ye>y0:
            
            c0=y1-ye+vy/vx*(xe-x1)
            c1=vy/vx
            ck=1
            lam=solpol(k,c0,c1,ck)
            time=large
            for l in range(0,len(lam)):
                tim=(lam[l]+xe-x1)/vx
                if xe<x1+vx*tim<x0 and ye>y1+vy*tim>y0:
                    if tim>0 and tim<time:
                        time=tim
            if time<large:
                return(x1+vx*time,y1+vy*time, (vx*time)^2+(vy*time)^2)
            else:
                return (0,0,large+1) 
                
            
                
        if xe<x0 and ye<y0:
            c0=y1-y0+vy/vx*(x0-x1)
            c1=vy/vx
            ck=(-1)^k
            lam=solpol(k,c0,c1,ck)
            time=large
            for l in range(0,len(lam)):
                tim=(lam[l]+x0-x1)/vx
                if xe<x1+vx*tim<x0 and ye<y1+vy*tim<y0:
                    if tim>0 and tim<time:
                        time=tim
            if time<large:
                return(x1+vx*time,y1+vy*time, (vx*time)^2+(vy*time)^2)
            else:
                return (0,0,large+1)  
              
            
        if xe>x0 and ye<y0:
            c0=y1-ye+vy/vx*(xe-x1)
            c1=vy/vx
            ck=(-1)^(k+1)
            lam=solpol(k,c0,c1,ck)
            time=large
            for l in range(0,len(lam)):
                tim=(lam[l]+xe-x1)/vx
                if xe>x1+vx*tim>x0 and ye<y1+vy*tim<y0:
                    if tim>0 and tim<time:
                        time=tim
            if time<large:
                return(x1+vx*time,y1+vy*time, (vx*time)^2+(vy*time)^2)
            else:
                return (0,0,large+1)  
            
        if xe>x0 and ye>y0:
            c0=y1-y0+vy/vx*(x0-x1)
            c1=vy/vx
            ck=-1
            lam=solpol(k,c0,c1,ck)
            time=large
            for l in range(0,len(lam)):
                tim=(lam[l]+x0-x1)/vx
                if xe>x1+vx*tim>x0 and ye>y1+vy*tim>y0:
                    if tim>0 and tim<time:
                        time=tim
            if time<large:
                return(x1+vx*time,y1+vy*time, (vx*time)^2+(vy*time)^2)
            else:
                return (0,0,large+1)
                  

    # m2 is the slope of vel, handling infinite case by making it large        
    if vel[0]==0:
            m2=1000000000
    else:
            m2=vel[1]/vel[0]
    if wall[6]==0:
        #print('checking arc')
        u1=qb(wall)
        u2=qe(wall)
        u3=ub(wall)
        C=center(u1,u2,u3)
        radi=pdistance(C,u1)
        #print('radius',radi)
        A=1+m2^2
        B=-2*C[0]+2*m2*(pos[1]-m2*pos[0]-C[1])
        c=C[0]^2+m2^2*pos[0]^2+2*m2*pos[0]*(C[1]-pos[1])+(pos[1]-C[1])^2-radi^2
        x1=(-B+(B^2-4*A*c)^(1/2))/(2*A)
        x2=(-B-(B^2-4*A*c)^(1/2))/(2*A)
        # This handles the cases where the trajectory misses the circle entirely
        if x1.imag()!=0:
            return (0,0,large+1)
        #if x2.real==False:
        #    return (0,0,large+1)
        else:
            y1=pos[1]+m2*(x1-pos[0])
            y2=pos[1]+m2*(x2-pos[0])
            #print('x1,y1,pointonarc(x1,y1,wall)',x1,y1,pointonarc(x1,y1,wall))
            #print('x2,y2,pointonarc(x2,y2,wall)',x2,y2,pointonarc(x2,y2,wall))
            d2=pdistance(pos,(x2,y2))
            d1=pdistance(pos,(x1,y1))
            #print(d1,d2)
            pointon1=pointonarc(x1,y1,wall) and d1>eps
            pointon2=pointonarc(x2,y2,wall) and d2>eps
            if pointon1:
                #print('made it here')
                # to this point there is nothing to prevent the point being the original point
                # also, we need to make such the intersection is in forward time
                #print('here', d1>eps, ((vel[0]>0 and x1-pos[0]>0) or (vel[0]<0 and x1-pos[0]<0)) , d1<d2 or pointon2==False or  (vel[0]<0 and x2-pos[0]>0) or (vel[0]>0 and x2-pos[0]<0) )
                if d1>eps and ((vel[0]>0 and x1-pos[0]>0) or (vel[0]<0 and x1-pos[0]<0)) and (d1<d2 or pointon2==False or (vel[0]<0 and x2-pos[0]>0) or (vel[0]>0 and x2-pos[0]<0)):
                    #print('returning x1')
                    return (x1,y1,d1)
            #print(x2,y2,pointon2)
            if pointon2:
                #print('made it to x2 part')
                #print('d2>eps,d2,eps',d2>eps,d2,eps)
                if d2>eps and ((vel[0]>0 and x2-pos[0]>0) or (vel[0]<0 and x2-pos[0]<0)):
                    #print('returning x2')
                    return (x2,y2,d2)
            #print(x1,y1,d1)
            #print(x2,y2,d2)
        #print('emergency exit')
        return(0,0,large+1)
    if wall[6]==1:
        # find the intersection point 
        if wall[2]==wall[0]:
            m1=(wall[3]-wall[1])/(eps)
        else:
            m1=(wall[3]-wall[1])/(wall[2]-wall[0])
        if m2==m1:
            m2=m2-eps
        x=(m2*pos[0]-pos[1]-m1*wall[0]+wall[1])/(m2-m1)
        y=pos[1]+m2*(x-pos[0])
        if ((x-pos[0])^2+(y-pos[1])^2)<eps:
            #print('not supposed to be here')
            return (0,0,large+1)
        else:
            #print('found a collision')
            return (x,y,((x-pos[0])^2+(y-pos[1])^2))

def next_wall(walls,rotational_position,x,y,rotational_velocity,vx,vy):
    #print('in next wall')
    best_dist=large
    bestx=x
    besty=y
    best_wall=0
    for i in range(0,len(walls)):
        #note: dist=distance squared
        (xnew,ynew,dist)=wall_collide((x,y),(vx,vy),walls[i])
        #print(i,'dist',dist)
        if eps<dist<best_dist:
            bestx=xnew
            besty=ynew
            best_dist=dist
            best_wall=i
    return ((best_dist/(rotational_velocity^2+vx^2+vy^2)^(1/2))*rotational_velocity+rotational_position,bestx,besty,best_wall)

def new_positions(walls,M0,M1,M2,N0,N1,N2):
    #print('new positions')
    Mw=matrix(QQ,m,n)
    for i in range(0,m):
        #print(i)
        for j in range(0,n):
            #$print(j)
            #show(M1)
            (M0[i,j],M1[i,j],M2[i,j],Mw[i,j])=next_wall(walls,M0[i,j],M1[i,j],M2[i,j],N0[i,j],N1[i,j],N2[i,j])
        #show(Ptemp)
    return (M0,M1,M2,Mw)

def get_tangent(wall,x,y):
    if wall[6]==1:
        return getangle(diff(qb(wall),qe(wall)))
    if wall[6]==0:
        #print('circ tan')
        u1=qb(wall)
        u2=qe(wall)
        u3=ub(wall)
        C=center(u1,u2,u3)
        perp=getangle(diff(C,(x,y)))
        return perp+pi/2
    if wall[6]>1:
        k=wall[6]
        #print(getangle([1,-k*(x-wall[2])^(k-1)]))
        if x>0 and y>0:
            return getangle([1,-k*(x-wall[2])^(k-1)])
        if x<0 and y>0:
            return getangle([1,(-1)^(k+1)*k*(x-wall[0])^(k-1)])
        if x<0 and y<0:
            return getangle([1,(-1)^(k)*k*(x-wall[2])^(k-1)])
        if x>0 and y<0:
            return getangle([1,k*(x-wall[0])^(k-1)])    
    else:
        return False

def reflect(wall,x,y,vr,vx,vy,gamma):
    V=matrix(RR,3,1)
    V[0,0]=vr
    V[1,0]=vx
    V[2,0]=vy
    #show(V)
    # omega is the angle of the line or tangent to the circle, oriented by the direction
    omega=get_tangent(wall,x,y)
    U1=rot(omega)
    U2=rot(-omega)
    if wall[9]==0:
        #print('here thu')
        #show(U1,U2)
        T=matrix(RR,n,n)
        T=U1*S*U2
        #show(V)
        V=T*V
    else:
        #print(U)
        a=RR(aa(gamma))
        b=RR(bb(gamma))
        U=matrix(RR,[[-a,b,0],[b,a,0],[0,0,-1]]) #rough collision with upward normal
        V=rot(omega)*U*rot(-omega)*V
    #show(V)
    return (V[0,0],V[1,0],V[2,0])

def new_velocities(walls,P1,P2,V0,V1,V2,Pw,gamma):
    for i in range(0,m):
        for j in range(0,n):
            (V0[i,j],V1[i,j],V2[i,j])=reflect(walls[Pw[i,j]],P1[i,j],P2[i,j],V0[i,j],V1[i,j],V2[i,j],gamma)
    return (V0,V1,V2)

def Draw_paths(X1,Y1,X2,Y2,col):
    paths=Graphics()
    #show(X1,X2,Y1,Y2)
    for i in range(0,m):
        for j in range(0,n):
            #print((O[i][j][1],O[i][j][2]),(N[i][j][1],N[i][j][2]))
            paths+=plot(line([(X1[i,j],Y1[i,j]),(X2[i,j],Y2[i,j])],color=col, thickness=1))
            #show(paths)
    return paths

# This tests Draw_paths
# P1=[[[1,1,1],[1,1,1],[1,1,1]],[[1,1,1],[1,1,1],[1,1,1]],[[1,1,1],[1,1,1],[1,1,1]]]
# P2=[[[1,2,2],[1,0,0],[1,2,4]],[[1,12,12],[1,12,12],[1,11,1]],[[1,11,1],[1,11,1],[1,11,21]]]
# testgraph=Draw_paths(P1,P2)
# show(testgraph)
# wall_segments is a k by 10 matrix, Renato's 9 plus the tenth: 0=smooth, 1=rough
# N_max is the maximum iterations before stopping
# draw 

def phaseangle(wall,  x,  y,p,q):
    if wall[6]==1:
        return RR(vecang((wall[4],wall[5]),(x,y)))
    if wall[6]==0:
        return RR(vecang((RR(cos(get_tangent(wall,p,q))),RR(sin(get_tangent(wall,p,q)))) ,(x,y)))
        #print(pang)
        #if pang<-pi/2:
        #    return pang+pi
        #else:
        #    return pang
    if wall[6]>1:
        return RR(vecang((RR(cos(get_tangent(wall,p,q))),RR(sin(get_tangent(wall,p,q)))) ,(x,y)))

def Billiard(wall_segments, N_max, draw, p, v,col,gamma):
    if draw==1:
        graph=draw_table(wall_segments)
    (P0,P1,P2,V0,V1,V2)=create_matrices(p,v)
    errorcount=0
    for i in range(0,N_max):
        OP1=P1[:]
        OP2=P2[:]
        (P0,P1,P2,Pwall)=new_positions(wall_segments,P0,P1,P2,V0,V1,V2)
        pathgraph=Draw_paths(OP1,OP2,P1,P2,col)
        graph=graph+pathgraph
        if wall_segments[Pwall[0,0]][10]==-1:
            (V0,V1,V2)=new_velocities(wall_segments,P1,P2,V0,V1,V2,Pwall,gamma)
        else:
            Pwall[0,0]= wall_segments[Pwall[0,0]][10]
            if Pwall[0,0]==0 or Pwall[0,0]==4:
                P1[0,0]=-P1[0,0]
            else:
                P2[0,0]=-P2[0,0]  
      
        if OP1==P1 and OP2==P2:
            errorcount+=1
            #print(i)
    # print('adjustments',errorcount)
    return (P0,P1,P2,V0,V1,V2,graph)

def wallparam(number,wall,x,y):
    return RR(number+((wall[0]-x)^2+(wall[1]-y)^2)^.5/((wall[0]-wall[2])^2+(wall[1]-wall[3])^2)^.5)
    #if wall[6]==1:
    #if number==2:
        #return RR(number+2*((wall[0]-x)^2+(wall[1]-y)^2)^.5/((wall[0]-wall[2])^2+(wall[1]-wall[3])^2)^.5)
    #else:
        #return RR(number+((wall[0]-x)^2+(wall[1]-y)^2)^.5/((wall[0]-wall[2])^2+(wall[1]-wall[3])^2)^.5)
        
    #else:
        #u1=qb(wall)
        #u2=qe(wall)
        #u3=ub(wall)
        #C=center(u1,u2,u3)
        #return RR(number+((wall[0]-x)^2+(wall[1]-y)^2)^.5/((wall[0]-wall[2])^2+(wall[1]-wall[3])^2)^.5)
     
def Billiardp(wall_segments, N_max, draw, p, v):
    if draw==1:
        graph=draw_table(wall_segments)
        p0=point((0,0))
    (P0,P1,P2,V0,V1,V2)=create_matrices(p,v)
    errorcount=0
    errorloc=0
    pl=[]
    for i in range(0,N_max):
        
        #print('loop',i)
        OP1=P1[:]
        OP2=P2[:]
        Ph1=V0[:]
        Ph2=V1[:]
        #show(V1,V2)
        (P0,P1,P2,Pwall)=new_positions(wall_segments,P0,P1,P2,V0,V1,V2)
        #print('made')
        (V0,V1,V2)=new_velocities(wall_segments,P1,P2,V0,V1,V2,Pwall,gamma)
        #pathgraph=Draw_paths(OP1,OP2,P1,P2)
        #phasegraph=Draw_paths(Ph1,Ph2,V0,V1)
        #show(pathgraph)
        ####graph=graph+pathgraph
        
        if Pwall>7:
            # and Pwall!=2 and Pwall!=4 and Pwall!=6:
            y=phaseangle(wall_segments[Pwall[0,0]],V1[0,0],V2[0,0],P1[0,0],P2[0,0])
            x=wallparam(Pwall[0,0],wall_segments[Pwall[0,0]],P1[0,0],P2[0,0])
            #print(cos(V0[0,0])*sin(y),sin(V0[0,0])*sin(y))
            #if (RR(sin(V0[0,0])*cos(y)-.15))^2+(RR(sin(V0[0,0])*sin(y))-.15)^2<.06^2:
            #if 3*pi/4-.2<y<3*pi/4+.2:
            pl+=[(x,RR(cos(y)))]
            pl+=[(x,-RR(cos(y)))]
        #if x>2:
        #    pl+=[(6-x,RR(cos(y)))]
        #    pl+=[(6-x,-RR(cos(y)))]
        #else:
        #    pl+=[(2-x,RR(cos(y)))]
        #    pl+=[(2-x,-RR(cos(y)))]
            
            
        #print(Po)
        # , rgbcolor=hue(index/80)
        #graph2=graph2+plot(Po)
        #show(graph2)
        if OP1==P1 and OP2==P2:
            errorcount+=1
            P1[0,0]=.9*P1[0,0]
        
        #    print('error')
        #    print(i)
        #return
        #if i>14:
        #    print('P1',P1)
        #    print(P2)
        #    print(V1)
        #    print(V2)
        #print(P0)
    #P=NewP
    #V=NewV
    #show(graph2, axes=False)
    print(errorcount)
    return (P0,P1,P2,V0,V1,V2,pl)

def Billiardtext(wall_segments, N_max, p, v, posvel):
    (P0,P1,P2,V0,V1,V2)=create_matrices(p,v)
    if posvel==True:
        orbitlist=[(P1[0,0],P2[0,0],V1[0,0],V2[0,0])]
    else:
        orbitlist=[(P1[0,0],P2[0,0])]
    errorcount=0
    for i in range(0,N_max):
        OP1=P1[:]
        OP2=P2[:]
        (P0,P1,P2,Pwall)=new_positions(wall_segments,P0,P1,P2,V0,V1,V2)
        (V0,V1,V2)=new_velocities(wall_segments,P1,P2,V0,V1,V2,Pwall,gamma)
        if posvel==True:
            orbitlist+=[(P1[0,0],P2[0,0],V1[0,0],V2[0,0])]
        else:
            orbitlist+=[(P1[0,0],P2[0,0])]
        if OP1==P1 and OP2==P2:
            errorcount+=1
            print('error')
            print(i)
            #return
        #if i>429:
        #    print('P1',P1)
        #    print(P2)
        #    print(V1)
        #    print(V2)
        #print(P0)
    #P=NewP
    #V=NewV
    print('adjustments',errorcount)
    return (orbitlist)


#hk1=[[RR(cos(pi/4)),RR(sin(pi/4)),RR(cos(3*pi/4)),RR(sin(3*pi/4)),-1,1,0,0,1,0],[RR(cos(3*pi/4)),RR(sin(3*pi/4)),RR(cos(5*pi/4)),RR(sin(5*pi/4)),-1,-1,0,0,1,0],[RR(cos(5*pi/4)),RR(sin(5*pi/4)),RR(cos(7*pi/4)),RR(sin(7*pi/4)),1,-1,0,0,1,0],[RR(cos(-pi/4)),RR(sin(-pi/4)),RR(cos(pi/4)),RR(sin(pi/4)),-.03,1,0,0,1,0]]

#hk2=[[0,1,-1+RR(cos(3*pi/4)),1+RR(sin(3*pi/4)),0,1,0,0,1,0],[-1+RR(cos(3*pi/4)),1+RR(sin(3*pi/4)),-1,0,-1,-1,0,0,1,0],[-1,0,-1+RR(cos(5*pi/4)),-1+RR(sin(5*pi/4)),-1,0,0,0,1,0],[-1+RR(cos(5*pi/4)),-1+RR(sin(5*pi/4)),0,-1,1,-1,0,0,1,0],[0,-1,0,1,-5,1,0,0,1,0]]



# coordinates [angle position, x, y]
p=[[0,-.5,0],[0,-.1,.1],[0,.1,-1],[0,.1,.1]]
# velocities
v=[[0,1,-1],[.1,1,2],[-.1,-1,-1],[-.1,2,-1]]

m=1
n=1

graph=Graphics()
graph2=Graphics()
pointlist=[]

tabsize=4

# wall_segment= [ starting x, starting y, ending x, ending y, starting vector x, starting vector y, 0=circle 1=line for k>2 k=polynomial degree k, 0=not end 1=end, number of component, -(k+1)=pass to wall k 0=smooth 1=rough ]

def ktable(r,l,k):
    # r is the radius of the disk, l is the length of the flat side of the central disperser, k is the degree of the corners
    tab=[[tabsize, r-tabsize, tabsize, tabsize-r, 0, 1, 1, 0, 1, 0, 4],[tabsize, tabsize-r, tabsize-r, tabsize,-1,0, 0,0,1,0,-1],[tabsize-r, tabsize, r-tabsize, tabsize, -1, 0, 1, 0, 1, 0,6],[r-tabsize, tabsize, -tabsize, tabsize-r,0,-1, 0,0,1,0,-1],[-tabsize, tabsize-r, -tabsize, r-tabsize, 0, -1, 1, 0, 1, 0,0],[-tabsize, r-tabsize, r-tabsize, -tabsize,1,0, 0,0,1,0,-1],[r-tabsize, -tabsize, tabsize-r, -tabsize, 1, 0, 1, 0, 1, 0, 2],[tabsize-r, -tabsize, tabsize, r-tabsize,0,1, 0,0,1,0,-1] ]
    tab+=[[l,-l-1,l+1,-l,1,0,k,0,2,0,-1],[l+1,-l,l+1,l,0,1,1,0,2,0,-1],[l+1,l,l,l+1,0,1,k,0,2,0,-1],[l,l+1,-l,l+1,-1,0,1,0,2,0,-1],[-l,l+1,-l-1,l,-1,0,k,0,2,0,-1],[-l-1,l,-l-1,-l,0,-1,1,0,2,0,-1],[-l-1,-l,-l,-l-1,0,-1,k,0,2,0,-1],[-l,-l-1,l,-l-1,1,0,1,0,2,0,-1]]
    return tab

graph=Graphics()
#for j in range(1,100):
#    graph+=list_plot([(j,j)], size=30, color=hue(j/100))
#graph.show()
    
    

showtableaxes=False

kmax=4
kinc=.3

rr=1.8
ll=.7


def ngon(n): 
    tab=[[1,0,RR(cos(2*pi/n)),RR(sin(2*pi/n)),RR(-cos((n-2)/(2*n))),RR(sin((n-2)/(2*n))),1,0,1,0,-1]]
    for i in range(1,n):
        tab+=[[RR(cos(i*2*pi/n)),RR(sin(i*2*pi/n)),RR(cos((i+1)*2*pi/n)),RR(sin((i+1)*2*pi/n)),RR(cos((i+1)*2*pi/n)-cos(i*2*pi/n)),RR(sin((i+1)*2*pi/n)-sin(i*2*pi/n)),1,0,1,0,-1]]
    return tab
    
def ngonr(n): 
    tab=[[1,0,RR(cos(2*pi/n)),RR(sin(2*pi/n)),RR(-cos((n-2)/(2*n))),RR(sin((n-2)/(2*n))),1,0,1,1,-1]]
    for i in range(1,n):
        tab+=[[RR(cos(i*2*pi/n)),RR(sin(i*2*pi/n)),RR(cos((i+1)*2*pi/n)),RR(sin((i+1)*2*pi/n)),RR(cos((i+1)*2*pi/n)-cos(i*2*pi/n)),RR(sin((i+1)*2*pi/n)-sin(i*2*pi/n)),1,0,1,1,-1]]
    return tab

def ngonth(n,th): 
    tab=[[1+th,0,RR((1+th)*cos(2*pi/n)),RR((1+th)*sin(2*pi/n)),RR(-(1+th)*cos((n-2)/(2*n))),RR((1+th)*sin((n-2)/(2*n))),1,0,1,0,-1]]
    for i in range(1,n):
        tab+=[[RR((1+th)*cos(i*2*pi/n)),RR((1+th)*sin(i*2*pi/n)),RR((1+th)*cos((i+1)*2*pi/n)),RR((1+th)*sin((i+1)*2*pi/n)),RR(cos((i+1)*2*pi/n)-cos(i*2*pi/n)),RR(sin((i+1)*2*pi/n)-sin(i*2*pi/n)),1,0,1,0,-1]]
    return tab

def ngonthr(n,th): 
    tab=[[1+th,0,RR((1+th)*cos(2*pi/n)),RR((1+th)*sin(2*pi/n)),RR(-(1+th)*cos((n-2)/(2*n))),RR((1+th)*sin((n-2)/(2*n))),1,0,1,1,-1]]
    for i in range(1,n):
        tab+=[[RR((1+th)*cos(i*2*pi/n)),RR((1+th)*sin(i*2*pi/n)),RR((1+th)*cos((i+1)*2*pi/n)),RR((1+th)*sin((i+1)*2*pi/n)),RR(cos((i+1)*2*pi/n)-cos(i*2*pi/n)),RR(sin((i+1)*2*pi/n)-sin(i*2*pi/n)),1,0,1,1,-1]]
    return tab
    
def ngonthrshift(n,th): 
    tab=[[RR((1+th)*cos(pi/n)),RR(-(1+th)*sin(pi/n)),RR((1+th)*cos(pi/n)),RR((1+th)*sin(pi/n)),0,1,1,0,1,1,-1]]
    for i in range(1,n):
        tab+=[[RR((1+th)*cos(i*2*pi/n-pi/n)), RR((1+th)*sin(i*2*pi/n-pi/n)),RR((1+th)*cos((i+1)*2*pi/n-pi/n)),RR((1+th)*sin((i+1)*2*pi/n-pi/n)),RR(cos((i+1)*2*pi/n-pi/n)-cos(i*2*pi/n-pi/n)),RR(sin((i+1)*2*pi/n-pi/n)-sin(i*2*pi/n-pi/n)),1,0,1,1,-1]]
    return tab

def ngon2(n): 
    tab=[]
    #[1,0,RR(cos(2*pi/n)),RR(sin(2*pi/n)),RR(-cos((n-2)/(2*n))),RR(sin((n-2)/(2*n))),1,0,1,0,-1]]
    for i in range(0,n):
        
        tab+=[[RR(cos(i*2*pi/n-pi/n)),RR(sin(i*2*pi/n-pi/n)),RR(cos((i+1)*2*pi/n-pi/n)),RR(sin((i+1)*2*pi/n-pi/n)),RR(cos((i+1)*2*pi/n-pi/n)-cos(i*2*pi/n-pi/n)),RR(sin((i+1)*2*pi/n-pi/n)-sin(i*2*pi/n-pi/n)),1,0,1,0,-1]]
    return tab

def ngonth2(n,th): 
    tab=[]
    #[1+th,0,RR((1+th)*cos(2*pi/n)),RR((1+th)*sin(2*pi/n)),RR(-(1+th)*cos((n-2)/(2*n))),RR((1+th)*sin((n-2)/(2*n))),1,0,1,0,-1]]
    for i in range(0,n):
        tab+=[[RR((1+th)*cos(i*2*pi/n-pi/n)),RR((1+th)*sin(i*2*pi/n-pi/n)),RR((1+th)*cos((i+1)*2*pi/n-pi/n)),RR((1+th)*sin((i+1)*2*pi/n-pi/n)),RR(cos((i+1)*2*pi/n-pi/n)-cos(i*2*pi/n-pi/n)),RR(sin((i+1)*2*pi/n-pi/n)-sin(i*2*pi/n-pi/n)),1,0,1,0,-1]]
    return tab


iterations=100


table=[
[1,0,2,0,1,0,1,0,1,1,-1],
[2,0,2,1,0,1,1,0,1,1,-1],[2,1,1,2,-1,1,1,0,1,1,-1],
#[1,1,1,2,0,1,1,0,1,1,-1],
[1,2,0,2,-1,0,1,0,1,1,-1],[0,2,0,1,0,-1,1,0,1,1,-1],
[0,1,1,0,1,-1,1,0,1,1,-1 ]]


#table=[[.1,1,-.1,1,-1,0,1,0,1,1,-1], 
#[-.1,1,-1,.1,0,-1,0,0,1,1,-1],
#[-1,.1,-1,-.1,0,-1,1,0,1,1,-1], 
#[-1,-.1,-.1,-1,1,0,0,0,1,1,-1],
#[-.1,-1,.1,-1,1,0,1,0,1,1,-1],
#[.1,-1,1,-.1,0,1,0,0,1,1,-1],
#[1,-.1,1,.1,0,1,1,0,1,1,-1],
#[1,.1,.1,1,-1,0,0,0,1,1,-1]
#]




#graph+=arrow((1.5,.5), (1.5+1/3*RR(cos(thet2)),.5+1/3*RR(sin(thet2))) ,color='black',width=5,zorder=5,arrowsize=9)
#graph+=arrow((.5,.5), (.5+1/3*RR(cos(thet)),.5+1/3*RR(sin(thet))) ,color='black',width=5,zorder=5,arrowsize=9)

graph+=graph2




@interact
def f(BilliardTable=selector(['square',  'triangle', 'pentagon', 'circle', 'ellipse'],buttons=True,  label='Select billiard table shape'),  MassType=selector(['Point Mass',  'Uniform', 'Hollow', 'Other'], buttons=True,  label='Select mass distribution of ball'), Collisions=selector([2,  5, 10, 50, 100, 500, 2000],buttons=True,  label='Number of Collisions'), angle=selector([-70, -45,  -23, -10, -5, 0, 5, 10, 23, 45, 70],buttons=True,  label='Angle in Degrees'),spin=slider(-5,5,step_size=.2, default=0, label='Spin of the ball'), auto_update=True):
    
    if MassType=='Point Mass':
        gamma=0
    elif MassType=='Uniform':
        gamma=RR(1/2^.5)
    elif MassType=='Hollow':
        gamma=1
    else:
        gamma=.6180

    if -90<angle<90:
        thet=angle*2*np.pi/360
    else:
        thet=0
    if BilliardTable!='circle' and BilliardTable!='ellipse':
        if BilliardTable=='rectangle':
            table=ngonthr(4,0)
            x0=-RR(np.cos(pi/5))
        if BilliardTable=='circle':
            table=ngonthr(391,0)
            x0=-RR(np.cos(pi/391))
    
        if BilliardTable=='square':
            table=ngonthrshift(4,0)
            x0=-RR(np.cos(pi/4)) 
        if BilliardTable=='triangle':
            table=ngonthr(3,0)
            x0=-RR(np.cos(pi/3))         
        if BilliardTable=='pentagon':
            table=ngonthr(5,0)
            x0=-RR(np.cos(pi/5))
        p=[[0,x0,0]]
        v=[[spin,RR(cos(thet)),RR(sin(thet))]]
        (P0,P1,P2,V0,V1,V2,graph2)=Billiard(table,Collisions,1,p,v,TrajColor,gamma)
        graph2+=arrow((x0,0), (x0+.2*RR(cos(thet)),.2*RR(sin(thet))) ,color='red',width=5,zorder=5,arrowsize=9)
        graph2.show(aspect_ratio=1, axes=False, figsize=10)
    else:
        Collisions=Collisions+1
        if BilliardTable=='circle':
            ec=0
            y0=-.999999999
        else:
            ec=.5
            y0=RR(-1/2^.5+.0000001) 
        vx1 = RR(cos(thet+pi/2))
        vy1 = RR(sin(thet+pi/2))
        E = vx1^2 + vy1^2 + spin^2
        spin = spin/math.sqrt(E)
        vx = vx1/math.sqrt(E)
        vy = vy1/math.sqrt(E)
        x0=0
        
        graphEll = ellipse((0, 0), 1, RR((1-ec)^.5), color=BorderColor, thickness=6) #Note that ec=eccentricity squared
        #graphvpp = circle((0,0),1, color='grey')
        #graph+= point((x0,y0), color=BorderColor, size=30) #records the starting point
        
        assert x0^2+y0^2/(1-ec)<1
        # Note that nothing prevents you from choosing a starting point outside the ellipse, you just get this warning
        #print("WARNING! WARNING! Outside of the ellipse!")
        #graph.show(axes=False)
        #return False
        #if show_focus==True:
        #    graph+= point((-sqrt(ec),0), color='red', size=50)
        #    graph+= point((sqrt(ec),0), color='red', size=50)
        # row=collision number, column=[rotation,x,y,spin,vx,vy]
        # Note that the states are set up to handle rotation, though we aren't using them yet
        states=np.zeros(shape=(Collisions,8))
        xf=0 #x velocity in frame
        yf=0 #y velocity in frame
        states[0]=[0,x0,y0,spin,vx,vy,xf,yf]
        
        for i in range(0,Collisions-1):
            # This updates the states--the actual running of the billiards is through this
            # The details are hidden in the definition of F above
            states[i+1]=F(states[i], gamma, ec)
    
        for j in range(0,Collisions-1):
            if (-1)^j>0:
                curcol='blue'
            else:
                curcol='red'
            graphEll+=plot(line([(states[j,1],states[j,2]),(states[j+1,1],states[j+1,2])],color=curcol))
        graphEll+=arrow((x0,y0), (x0+vx1/3,y0+vy1/3) ,color='magenta',width=5,zorder=5,arrowsize=9)
        
        graphEll.show(axes=False)
        
#################################################
###### Introduction to Billiards: End ###########
#################################################        
  
  </script>
</div>
  
  
     <ul>
      <font face="Verdana" size="4">
  <li>Can you find settings which appear to fill the entire table in an orderly way?</li>
  <li>Can you find settings which appear to fill the entire table is a random or chaotic way?</li>
  <li>Can you find an example of "invariance", that is, an example where the trajectories will not 
    fill the billiard table but be restricted to certain portions?</li>
  <li>A trajectory is "periodic" if it returns to its starting position and velocity after a finite number of collisions and then repeats. 
        Can you choose settings to get a periodic trajectory?</li>
  <li> Can you find a table and a mass distribution such that ALL of the trajectories are periodic?</li> 
</ul> 
  <p>
   
     </p></font><br />
              



  
    <footer class="footer navbar-static-bottom">
     <div class="container">
     <br><br>
     <p class="text-muted small">Last modified January 7 2020</p>
     </div>
  </footer>
    
      

